

```{r setup}
library(compr)
library(broom)
library(tidyverse)
```

# build matrix function
```{r}
build_model_mat <- function(formula, data, p1, p2,
                            p1_effects = ~ 1, p2_effects = ~ 1,
                            ref_player = NULL) {
  model_frame_nocomp <- model.frame(formula, na.action =
                                      stats::na.pass, data = data)
  model_matrix_nocomp <- model.matrix(formula,
                                      model.frame(formula, data,
                                                  na.action = stats::na.pass))

  ## model.response(model_frame_nocomp, type = "numeric") |> matrix
  response_matrix <- model_frame_nocomp[ ,1 , drop = FALSE]
  player1_vec <- data |> dplyr::pull(p1)
  player2_vec <- data |> dplyr::pull(p2)

  players_unique <- c(player1_vec,
                      player2_vec) |>
    unique()
  
  if (!(ref_player %in% players_unique)) {
  warning("ref_player is not in players_unique.")
  stop()
}

  p1_mat <- model.matrix(p1_effects,
                         model.frame(p1_effects, data,
                                     na.action = stats::na.pass))

  p2_mat <- model.matrix(p2_effects,
                         model.frame(p2_effects, data,
                                     na.action = stats::na.pass))


  p1_mat_split <- lapply(seq_len(ncol(p1_mat)),
                         function(x) p1_mat[ , x])
  names(p1_mat_split) <- colnames(p1_mat)

  p2_mat_split <- lapply(seq_len(ncol(p2_mat)),
                         function(x) p2_mat[ , x])
  names(p2_mat_split) <- colnames(p2_mat)


  model_matrix_list <- purrr::pmap(list(val1 = p1_mat_split,
                                        val2 = p2_mat_split,
                                        names = p1_mat_split |> names()),
                                   create_d_mat,
                                   vec = rep(0, length(players_unique)),
                                   players = players_unique,
                                   player1_vec = player1_vec,
                                   player2_vec = player2_vec)

  comp_matrix_full <- do.call(cbind, model_matrix_list)

  if (is.null(ref_player)) {
    ref_player <- players_unique[1]
  }

  comp_matrix_red <- comp_matrix_full[ ,-which(players_unique == ref_player)]


  full_matrix <- cbind(response_matrix, model_matrix_nocomp, comp_matrix_red)

  mat_list <- list(full_matrix = full_matrix,
                   ref_player = ref_player,
                   data = data,
                   p1 = p1,
                   p2 = p2,
                   p1_effects = p1_effects,
                   p2_effects = p2_effects,
                   og_formula = formula)
}
```


# fit model function
```{r}
fit_model <- function(mat_list, family){

  df_for_glm <- mat_list[["full_matrix"]][stats::complete.cases(mat_list[["full_matrix"]]), ] #|> as.matrix()

  response_column <- colnames(df_for_glm)[1]

  og_formula <- paste(response_column, "~ . -", response_column,
                       "- ", 1) ## drops second intercept

  formula_obj <- as.formula(og_formula)

  # Use the formula object in glm
  model_out <- stats::glm(formula_obj, data = df_for_glm, family = family)
  model_out$ref_player <- mat_list[["ref_player"]]
  model_out$og_data <- mat_list[["data"]]
  model_out$p1 <- mat_list[["p1"]]
  model_out$p2 <- mat_list[["p2"]]
  model_out$p1_effects <- mat_list[["p1_effects"]]
  model_out$p2_effects <- mat_list[["p2_effects"]]
  model_out$og_formula <- mat_list[["og_formula"]]
  model_out
}
```


# comp_glm function
```{r}
comp_glm <- function(formula, data, p1, p2, p1_effects = ~ 1, p2_effects = ~ 1, ref_player = NULL, family = "binomial"){
  mat_list <- build_model_mat(formula, data, p1, p2, p1_effects, p2_effects, ref_player)
  model_out <- fit_model(mat_list, family = family)
  model_out
}
```


# Augment function
```{r}
aug_mod <- function(newdata, comp_mod, ...){
  new_bound_df <- bind_rows(comp_mod[["og_data"]], newdata)
  mat_list <- build_model_mat(formula = comp_mod[["og_formula"]],
                  data = new_bound_df, 
                  p1 = comp_mod[["p1"]],
                  p2 = comp_mod[["p2"]], 
                  p1_effects = comp_mod[["p1_effects"]],
                  p2_effects = comp_mod[["p2_effects"]],
                  ref_player = comp_mod[["ref_player"]])
  full_matrix <- mat_list[["full_matrix"]]
  aug_df <- full_matrix %>% tail(nrow(full_matrix)-nrow(comp_mod[["og_data"]]))
  aug_mod <- augment(comp_mod, newdata = aug_df, se_fit = TRUE, ...) |> select(.fitted, .se.fit)
  aug_mod_out <- bind_cols(newdata, aug_mod)
}
# Should I clean up the output?
# Bind cols with new_df 
# Do it in aug_mod
# Make a quorto website 
#rename from formula_str to og_formula

```


```{r}
comp_mod_tennis <- comp_glm(formula = point_winner ~ -1,
         data = tennis_point,
         p1_effects = ~ point_server1, p2_effects = ~ point_server2,
         ref_player = "James Wolpe",
         p1 = "player1", p2 = "player2")

#3. Create new data
unique_players <- comp_mod_tennis[["model"]][-c(1, 2)] |> names()

new_df <- data.frame(
  player1 = rep(comp_mod_tennis$ref_player, length(unique_players)),
  player2 = unique_players
)
```

























```{r}
#plot_win_perc_with_error_bars <- function(model, data, player_of_interest){

  aug_df_out <- aug_mod(new_df, comp_mod_tennis)
  
  
  perc_aug_df_out <- aug_df_out |> 
    mutate( 
      win_perc = exp(.fitted)/ (1+exp(.fitted)),
      u_bound = exp(.fitted + .se.fit)/ (1+ exp(.fitted + .se.fit)),
      l_bound = exp(.fitted - .se.fit)/ (1+ exp(.fitted - .se.fit))
    ) |> mutate(fct_reorder(as.factor(perc_aug_df_out[2]), win_perc))
  
  
  ggplot(perc_aug_df_out, aes(x = p2, y = win_perc)) +
    geom_point(size = 2) +
    geom_errorbar(aes(ymin = l_bound, ymax = u_bound)) +
    labs(x = "Player",
         y = "Win Percentage",
         title = paste(comp_mod_tennis["ref_player"], "Plot"))+
    scale_y_continuous(labels = scales::percent_format(scale = 100))+
    theme_bw() +
    coord_flip()

  #select the name of the first column of perc_aug_df_out
  names(perc_aug_df_out[1])
  # shiny book tidy evaluation .data[[]]

```






```{r}
library(comprjames)
library(tidyverse)
library(rvest)
comp_mod <- comp_glm(home_winner ~ -1, data = nba_game,
                     p1 = "home", p2 = "away",
                     p1_effects = ~ home_court_1,
                     p2_effects = ~ home_court_2,
                     ref_player = "Boston Celtics"
                     )

```

```{r}
# Define the list of URLs
urls <- c(
  "https://www.basketball-reference.com/leagues/NBA_2024_games-october.html",
  "https://www.basketball-reference.com/leagues/NBA_2024_games-november.html",
  "https://www.basketball-reference.com/leagues/NBA_2024_games-december.html",
  "https://www.basketball-reference.com/leagues/NBA_2024_games-january.html",
  "https://www.basketball-reference.com/leagues/NBA_2024_games-february.html",
  "https://www.basketball-reference.com/leagues/NBA_2024_games-march.html",
  "https://www.basketball-reference.com/leagues/NBA_2024_games-april.html"
)

# Initialize an empty list to store DataFrames
dfs <- list()

# Loop through the URLs and scrape data
for (url in urls) {
  page_html <- url %>%
    read_html()
  
  df <- page_html %>%
    html_nodes("table") %>%
    .[[1]] %>%
    html_table(header = TRUE)
  
  dfs[[url]] <- df
}

# Combine the DataFrames into one
nba_game <- do.call(rbind, dfs)
rownames(nba_game) <- NULL

nba_game <- nba_game[1:1230, ]
nba_game <- nba_game[, -c(2, 7, 9, 10, 11)]

nba_game <- nba_game |>
  rename(
    date = 1,
    away = 2,
    away_pts = 3,
    home = 4,
    home_pts = 5,
    OT = 6
  )

nba_season <- nba_game |> #there are both OT and 2OT
  mutate(OT = ifelse(OT == "", FALSE, TRUE),
         home_winner = ifelse(home_pts > away_pts, TRUE, FALSE),
         pts_diff = home_pts - away_pts)
# convert date to date format
nba_season$date <- as.Date(nba_season$date, format = "%a, %b %d, %Y")


nba_season <- nba_season %>% #there are both OT and 2OT
  mutate(OT = ifelse(OT == "", FALSE, TRUE),
         home_winner = ifelse(home_pts > away_pts, TRUE, FALSE),
         pts_diff = home_pts - away_pts,
         home_court_1 = 1,
         home_court_2 = 0
  )

#get todays date
today <- Sys.Date()

# split up nba_season 2 df's one before today and one after
nba_season_before <- nba_season |>
  filter(date < today)

#get all of todays games
todays_games <- nba_season |>
  filter(date == today) |>
  select(-date, -away_pts, -home_pts, -OT, -home_winner, -pts_diff, -home_court_1, -home_court_2)

comp_mod <- comp_glm(home_winner ~ -1, data = nba_season_before,
                     family = binomial,
                     p1 = "home", p2 = "away",
                     p1_effects = ~ home_court_1,
                     p2_effects = ~ home_court_2,
                     ref_player = "Boston Celtics"
                     )


foo <-aug_mod(todays_games, comp_mod)

foo |> 
    mutate( 
      win_perc = exp(.fitted)/ (1+exp(.fitted)),
      u_bound = exp(.fitted + .se.fit)/ (1+ exp(.fitted + .se.fit)),
      l_bound = exp(.fitted - .se.fit)/ (1+ exp(.fitted - .se.fit))
    )
```

